<html dir="LTR" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:tool="http://www.microsoft.com/tooltip">
    <head>
        <meta http-equiv="Content-Type" content="text/html; CHARSET=utf-8"></meta>
        <meta name="save" content="history"></meta>
        <title>2.1.4.12 Algorithm to Check for an Oplock Break</title>
        <xml>
            <mshelp:toctitle title="2.1.4.12 Algorithm to Check for an Oplock Break"></mshelp:toctitle>
            <mshelp:rltitle title="[MS-FSA]: Algorithm to Check for an Oplock Break"></mshelp:rltitle>
            <mshelp:keyword index="A" term="306239fb-cb60-49fe-b293-df4d1a5f757a"></mshelp:keyword>
            <mshelp:attr name="DCSext.ContentType" value="open specification"></mshelp:attr>
            <mshelp:attr name="AssetID" value="306239fb-cb60-49fe-b293-df4d1a5f757a"></mshelp:attr>
            <mshelp:attr name="TopicType" value="kbRef"></mshelp:attr>
            <mshelp:attr name="DCSext.Title" value="[MS-FSA]: Algorithm to Check for an Oplock Break" />
        </xml>
    </head>
    <body>
        <div id="header">
            <h1 class="heading">2.1.4.12 Algorithm to Check for an Oplock Break</h1>
        </div>
        <div id="mainSection">
            <div id="mainBody">
                <div id="allHistory" class="saveHistory"></div>
                <div id="sectionSection0" class="section" name="collapseableSection">
                    

<p>The inputs for this algorithm are:</p>

<ul><li><p><span><span> 
</span></span><b>Open:</b> The <b>Open</b> being used in the request calling
this algorithm.</p>

</li><li><p><span><span> 
</span></span><b>Oplock:</b> The <b>Oplock</b> being checked.</p>

</li><li><p><span><span> 
</span></span><b>Operation:</b> A code describing the operation being
processed.</p>

</li><li><p><span><span> 
</span></span><b>OpParams:</b> Parameters associated with the <b>Operation</b>
code that are passed in from the calling request. For example, if <b>Operation</b>
is OPEN, as specified in section <a href="8ada5fbe-db4e-49fd-aef6-20d54b748e40.html">2.1.5.1</a>, then <b>OpParams</b>
will have the members <b>DesiredAccess</b> and <b>CreateDisposition</b>. Each
of these is a parameter to the open request as specified in section 2.1.5.1.
This parameter could be empty, depending on the <b>Operation</b> code.</p>

</li><li><p><span><span> 
</span></span><b>Flags:</b> An optional parameter. If unspecified it is
considered to contain 0. Valid nonzero values are:</p>

<ul><li><p><span><span>  </span></span>PARENT_OBJECT</p>

</li></ul></li></ul><p>The algorithm uses the following local variables:</p>

<ul><li><p><span><span> 
</span></span>Boolean values (initialized to FALSE): <i>BreakToTwo</i>, <i>BreakToNone</i>,
<i>NeedToWait</i></p>

</li><li><p><span><span> 
</span></span><i>BreakCacheState </i>– MAY contain 0 or a combination of one or
more of READ_CACHING, WRITE_CACHING, or HANDLE_CACHING, as specified in section
<a href="6e14455e-3b25-4629-8435-cdeae7bb34a9.html">2.1.1.10</a>.  Initialized
to 0.</p>

<ul><li><p><span><span>  </span></span>Note
that there are only four legal nonzero combinations of flags for <i>BreakCacheState</i>:</p>

<ul><li><p><span><span> 
</span></span>(READ_CACHING|WRITE_CACHING|HANDLE_CACHING)</p>

</li><li><p><span><span> 
</span></span>(READ_CACHING|WRITE_CACHING)</p>

</li><li><p><span><span> 
</span></span>WRITE_CACHING</p>

</li><li><p><span><span> 
</span></span>HANDLE_CACHING</p>

</li></ul></li></ul></li></ul><p>Pseudocode for the algorithm is as follows:</p>

<p>If <b>Oplock</b> is not empty and <b>Oplock.State</b> is not
NO_OPLOCK:</p>

<ul><li><p><span><span> 
</span></span>If <b>Flags</b> contains PARENT_OBJECT<a id="Appendix_A_Target_41"></a><a href="4e3695bd-7574-4f24-a223-b4679c065b63.html#Appendix_A_41" aria-label="Product behavior note 41">&lt;41&gt;</a>:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to (READ_CACHING|WRITE_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>Else:</p>

<ul><li><p><span><span>  </span></span>Switch
(<b>Operation</b>):</p>

<ul><li><p><span><span> 
</span></span>Case OPEN, as specified in section 2.1.5.1:</p>

<ul><li><p><span><span> 
</span></span>If <b>OpParams.DesiredAccess</b> contains no flags other than
FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES, or SYNCHRONIZE, the algorithm
returns at this point.</p>

</li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <b>OpParams.CreateDisposition</b> is FILE_SUPERSEDE,
FILE_OVERWRITE, or FILE_OVERWRITE_IF:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakToNone</i> to TRUE, set <i>BreakCacheState</i> to
(READ_CACHING|WRITE_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>Else</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakToTwo</i> to TRUE, set <i>BreakCacheState </i>to
WRITE_CACHING.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case OPEN_BREAK_H, as specified in section 2.1.5.1:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakCacheState </i>to HANDLE_CACHING.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case CLOSE, as specified in section <a href="d142c93a-72bc-4b05-9d96-8e00371c3308.html">2.1.5.4</a>:</p>

<ul><li><p><span><span> 
</span></span>If <b>Oplock.IIOplocks</b> is not empty:</p>

<ul><li><p><span><span> 
</span></span>For each <b>Open</b> <i>ThisOpen</i> in <b>Oplock.IIOplocks</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisOpen</i> == <b>Open</b>:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisOpen</i> from <b>Oplock.IIOplocks</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the <a href="682f0f59-385c-4351-b81a-3b234f53db03.html#gt_434b0234-e970-4e8c-bdfa-e16a30d96703">server</a>
of an oplock break according to the algorithm in section <a href="51079fa1-f880-4170-859f-4de74c36f5e6.html">2.1.5.17.3</a>, setting the
algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to FALSE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to <a href="2e46c07d-ceb2-4f72-918a-1cb719adff8f.html">2.1.5.17.2</a>.)</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li><li><p><span><span> 
</span></span>Recompute <b>Oplock.State</b> according to the algorithm in
section <a href="e17d93a0-7857-44fa-a0fa-3b3554a7b64c.html">2.1.4.13</a>,
passing <b>Oplock</b> as the <b>ThisOplock</b> parameter.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.ROplocks</b> is not empty:</p>

<ul><li><p><span><span> 
</span></span>For each <b>Open</b> <i>ThisOpen</i> in <b>Oplock.ROplocks</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisOpen</i> == <b>Open</b>:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisOpen</i> from <b>Oplock.ROplocks</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to FALSE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to
STATUS_OPLOCK_HANDLE_CLOSED.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.2.)</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li><li><p><span><span> 
</span></span>Recompute <b>Oplock.State</b> according to the algorithm in
section 2.1.4.13, passing <b>Oplock</b> as the <b>ThisOplock</b> parameter.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.RHOplocks</b> is not empty:</p>

<ul><li><p><span><span> 
</span></span>For each <b>Open</b> <i>ThisOpen</i> in <b>Oplock.RHOplocks</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisOpen</i> == <b>Open</b>:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisOpen</i> from <b>Oplock.RHOplocks</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to FALSE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to
STATUS_OPLOCK_HANDLE_CLOSED.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.2.)</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li><li><p><span><span> 
</span></span>Recompute <b>Oplock.State</b> according to the algorithm in
section 2.1.4.13, passing <b>Oplock</b> as the <b>ThisOplock</b> parameter.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.RHBreakQueue</b> is not empty:</p>

<ul><li><p><span><span> 
</span></span>For each <b>RHOpContext</b> <i>ThisContext</i> in <b>Oplock.RHBreakQueue</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisContext</i>.<b>Open</b> == <b>Open</b>:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisContext</i> from <b>Oplock.RHBreakQueue</b>.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li><li><p><span><span> 
</span></span>Recompute <b>Oplock.State</b> according to the algorithm in
section 2.1.4.13, passing <b>Oplock</b> as the <b>ThisOplock</b> parameter.</p>

</li><li><p><span><span> 
</span></span>For each <b>Open</b> <i>WaitingOpen</i> on <b>Oplock.WaitList</b>:</p>

<ul><li><p><span><span> 
</span></span>If <b>Oplock.RHBreakQueue</b> is empty:</p>

<ul><li><p><span><span> 
</span></span>Indicate that the operation associated with <i>WaitingOpen</i>
can continue according to the algorithm in section <a href="dc5efd56-0a09-49a3-aaf3-b33ad19254e5.html">2.1.4.12.1</a>, setting <b>OpenToRelease</b>
equal to <i>WaitingOpen</i>.</p>

</li><li><p><span><span> 
</span></span>Remove <i>WaitingOpen</i> from <b>Oplock.WaitList</b>.</p>

</li></ul></li><li><p><span><span> 
</span></span>Else</p>

<ul><li><p><span><span> 
</span></span>If the value on every <b>RHOpContext.Open.TargetOplockKey</b> on <b>Oplock.RHBreakQueue</b>
is equal to <i>WaitingOpen</i> <b>.TargetOplockKey</b>:</p>

<ul><li><p><span><span> 
</span></span>Indicate that the operation associated with <i>WaitingOpen</i>
can continue according to the algorithm in section 2.1.4.12.1, setting <b>OpenToRelease</b>
equal to <i>WaitingOpen</i>.</p>

</li><li><p><span><span> 
</span></span>Remove <i>WaitingOpen</i> from <b>Oplock.WaitList</b>.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <b>Open</b> equals <b>Oplock.ExclusiveOpen</b></p>

<ul><li><p><span><span> 
</span></span>If <b>Oplock.State</b> contains none of BREAK_TO_TWO,
BREAK_TO_NONE, BREAK_TO_TWO_TO_NONE, BREAK_TO_READ_CACHING,
BREAK_TO_WRITE_CACHING, BREAK_TO_HANDLE_CACHING, or BREAK_TO_NO_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to FALSE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to:</p>

<ul><li><p><span><span> 
</span></span>STATUS_OPLOCK_HANDLE_CLOSED if <b>Oplock.State</b> contains any
of READ_CACHING, WRITE_CACHING, or HANDLE_CACHING.</p>

</li><li><p><span><span> 
</span></span>STATUS_SUCCESS otherwise.</p>

</li></ul></li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to <a href="4f654d5a-27e1-4b34-9bd4-8b86cd99fc2c.html">2.1.5.17.1</a>.)</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>Set <b>Oplock.ExclusiveOpen</b> to NULL.</p>

</li><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to NO_OPLOCK.</p>

</li><li><p><span><span> 
</span></span>For each <b>Open</b> <i>WaitingOpen</i> on <b>Oplock.WaitList</b>:</p>

<ul><li><p><span><span> 
</span></span>Indicate that the operation associated with <i>WaitingOpen</i>
can continue according to the algorithm in section 2.1.4.12.1, setting <b>OpenToRelease</b>
equal to <i>WaitingOpen</i>.</p>

</li><li><p><span><span> 
</span></span>Remove <i>WaitingOpen</i> from <b>Oplock.WaitList</b>.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case READ, as specified in section <a href="aa57e052-40d4-4d9f-837d-2b0ce7c87cf4.html">2.1.5.2</a>:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakToTwo</i> to TRUE</p>

</li><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to WRITE_CACHING.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case FLUSH_DATA, as specified in section <a href="0de7dc40-9627-437e-a4df-c4696cdc3d02.html">2.1.5.6</a>:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakToTwo</i> to TRUE</p>

</li><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to WRITE_CACHING.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case LOCK_CONTROL, as specified in section <a href="369103ec-a8af-452b-8006-aff07b925b61.html">2.1.5.7</a>:</p>

</li><li><p><span><span> 
</span></span>Case WRITE, as specified in section <a href="fbf656c3-b897-4b9c-abfd-7c8d876d77a1.html">2.1.5.3</a>:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakToNone</i> to TRUE</p>

</li><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to (READ_CACHING|WRITE_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case SET_INFORMATION, as specified in section <a href="ced66da6-59de-4a8e-857f-6323b1be1439.html">2.1.5.14</a>:</p>

<ul><li><p><span><span> 
</span></span>Switch (<b>OpParams.FileInformationClass</b>):</p>

<ul><li><p><span><span> 
</span></span>Case FileEndOfFileInformation:</p>

</li><li><p><span><span> 
</span></span>Case FileAllocationInformation:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakToNone</i> to TRUE</p>

</li><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to (READ_CACHING|WRITE_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case FileRenameInformation:</p>

</li><li><p><span><span> 
</span></span>Case FileLinkInformation:</p>

</li><li><p><span><span> 
</span></span>Case FileShortNameInformation:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to HANDLE_CACHING.</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.State</b> contains BATCH_OPLOCK, set <i>BreakToNone</i>
to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case FileDispositionInformation:</p>

<ul><li><p><span><span> 
</span></span>If <b>OpParams.DeleteFile</b> is TRUE,</p>

</li><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to HANDLE_CACHING.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li></ul></li><li><p><span><span> 
</span></span>EndSwitch // FileInfoClass</p>

</li><li><p><span><span> 
</span></span>Case FS_CONTROL, as specified in section <a href="204a8ad5-cd6a-4569-8153-2d5263c5f32e.html">2.1.5.9</a>:</p>

<ul><li><p><span><span> 
</span></span>If <b>OpParams.ControlCode</b> is FSCTL_SET_ZERO_DATA:</p>

<ul><li><p><span><span> 
</span></span>Set <i>BreakToNone</i> to TRUE.</p>

</li><li><p><span><span> 
</span></span>Set <i>BreakCacheState</i> to (READ_CACHING|WRITE_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li></ul></li></ul></li><li><p><span><span>  </span></span>EndSwitch
// <b>Operation</b></p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <i>BreakToTwo</i> is TRUE:</p>

<ul><li><p><span><span>  </span></span>If
(<b>Oplock.State</b> != LEVEL_TWO_OPLOCK) and</p>

<p>((<b>Oplock.ExclusiveOpen</b>
is empty) or</p>

<p>(<b>Oplock.ExclusiveOpen.TargetOplockKey</b>
!= <b>Open.TargetOplockKey</b>)):</p>

<ul><li><p><span><span> 
</span></span>If (<b>Oplock.State</b> contains EXCLUSIVE) and </p>

<p>(<b>Oplock.State</b>
contains none of READ_CACHING, WRITE_CACHING, or HANDLE_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <b>Oplock.State</b> contains none of BREAK_TO_TWO,
BREAK_TO_NONE, BREAK_TO_TWO_TO_NONE, BREAK_TO_READ_CACHING,
BREAK_TO_WRITE_CACHING, BREAK_TO_HANDLE_CACHING, or BREAK_TO_NO_CACHING:</p>

<ul><li><p><span><span> 
</span></span>// <b>Oplock.State</b> MUST contain either LEVEL_ONE_OPLOCK or
BATCH_OPLOCK.</p>

</li><li><p><span><span> 
</span></span>Set BREAK_TO_TWO in <b>Oplock.State</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_TWO.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.1.)</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>The operation that called this algorithm MUST be made cancelable
by inserting it into <b>CancelableOperations.CancelableOperationList</b>.</p>

</li><li><p><span><span> 
</span></span>Insert <b>Open</b> into <b>Oplock.WaitList</b>.</p>

</li><li><p><span><span> 
</span></span>The operation that called this algorithm waits until the oplock
break is acknowledged, as specified in section <a href="1ab3ff72-63f0-4255-b9a9-9591ec9cdb2f.html">2.1.5.18</a>, or the operation
is canceled.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span>  </span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <i>BreakToNone</i> is TRUE:</p>

<ul><li><p><span><span>  </span></span>If
(<b>Oplock.State</b> == LEVEL_TWO_OPLOCK) or </p>

<p>(<b>Oplock.ExclusiveOpen</b>
is empty) or</p>

<p>(<b>Oplock.ExclusiveOpen.TargetOplockKey</b>
!= <b>Open.TargetOplockKey</b>):</p>

<ul><li><p><span><span> 
</span></span>If (<b>Oplock.State</b> != NO_OPLOCK) and</p>

<p>(<b>Oplock.State</b>
contains neither WRITE_CACHING nor HANDLE_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <b>Oplock.State</b> contains none of LEVEL_TWO_OPLOCK,
BREAK_TO_TWO, BREAK_TO_NONE, BREAK_TO_TWO_TO_NONE, BREAK_TO_READ_CACHING,
BREAK_TO_WRITE_CACHING, BREAK_TO_HANDLE_CACHING, or BREAK_TO_NO_CACHING:</p>

<ul><li><p><span><span> 
</span></span>// There could be a READ_CACHING-only oplock here. Those are
broken later on.</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.State</b> contains READ_CACHING, go to the <i>LeaveBreakToNone</i>
label.</p>

</li><li><p><span><span> 
</span></span>Set BREAK_TO_NONE in <b>Oplock.State</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.1.)</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <b>Oplock.State</b> equals LEVEL_TWO_OPLOCK or
(LEVEL_TWO_OPLOCK|READ_CACHING):</p>

<ul><li><p><span><span> 
</span></span>For each <b>Open</b> <i>ThisOpen</i> in <b>Oplock.IIOplocks</b>:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisOpen</i> from <b>Oplock.IIOplocks</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to FALSE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.2.)</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.State</b> equals (LEVEL_TWO_OPLOCK|READ_CACHING):</p>

<ul><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> equal to READ_CACHING.</p>

</li></ul></li><li><p><span><span> 
</span></span>Else</p>

<ul><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> equal to NO_OPLOCK.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>Go to the <i>LeaveBreakToNone</i> label.</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <b>Oplock.State</b> contains BREAK_TO_TWO:</p>

<ul><li><p><span><span> 
</span></span>Clear BREAK_TO_TWO from <b>Oplock.State</b>.</p>

</li><li><p><span><span> 
</span></span>Set BREAK_TO_TWO_TO_NONE in <b>Oplock.State</b>.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.ExclusiveOpen</b> is not empty, and <b>Oplock.ExclusiveOpen.TargetOplockKey</b>
equals <b>Open.TargetOplockKey</b>, go to the <i>LeaveBreakToNone</i> label.</p>

</li><li><p><span><span> 
</span></span>The operation that called this algorithm MUST be made cancelable
by inserting it into <b>CancelableOperations.CancelableOperationList</b>.</p>

</li><li><p><span><span> 
</span></span>Insert <b>Open</b> into <b>Oplock.WaitList</b>.</p>

</li><li><p><span><span> 
</span></span>The operation that called this algorithm waits until the oplock
break is acknowledged, as specified in section 2.1.5.18, or the operation is
canceled.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span>  </span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

<p><i>LeaveBreakToNone</i>
(goto destination label):</p>

</li><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> is not 0:</p>

<ul><li><p><span><span>  </span></span>If <b>Oplock.State</b>
contains any flags that are in <i>BreakCacheState</i>:</p>

<ul><li><p><span><span> 
</span></span>If <b>Oplock.ExclusiveOpen</b> is not empty, call the algorithm
in section <a href="abeec095-2dee-4892-acfc-2eeb3d241a3d.html">2.1.4.12.2</a>,
passing <b>Open</b> as the <b>OperationOpen</b> parameter, <b>Oplock.ExclusiveOpen</b>
as the <b>OplockOpen</b> parameter, and <b>Flags</b> as the <b>Flags</b>
parameter. If the algorithm returns TRUE:</p>

<ul><li><p><span><span> 
</span></span>The algorithm returns at this point.</p>

</li></ul></li><li><p><span><span> 
</span></span>Switch (<b>Oplock.State</b>):</p>

<ul><li><p><span><span> 
</span></span>Case (READ_CACHING|HANDLE_CACHING|MIXED_R_AND_RH):</p>

</li><li><p><span><span> 
</span></span>Case READ_CACHING:</p>

</li><li><p><span><span> 
</span></span>Case (LEVEL_TWO_OPLOCK|READ_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains READ_CACHING:</p>

<ul><li><p><span><span> 
</span></span>For each <b>Open</b> <i>ThisOpen</i> in <b>Oplock.ROplocks</b>:</p>

<ul><li><p><span><span> 
</span></span>Call the algorithm in section 2.1.4.12.2, passing <b>Open</b> as
the <b>OperationOpen</b> parameter, <i>ThisOpen</i> as the <b>OplockOpen</b>
parameter, and <b>Flags</b> as the <b>Flags</b> parameter. If the algorithm
returns FALSE:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisOpen</i> from <b>Oplock.ROplocks</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to FALSE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.2.)</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <b>Oplock.State</b> equals
(READ_CACHING|HANDLE_CACHING|MIXED_R_AND_RH):</p>

<ul><li><p><span><span> 
</span></span>// Do nothing; FALL THROUGH to next Case statement.</p>

</li></ul></li><li><p><span><span> 
</span></span>Else</p>

<ul><li><p><span><span> 
</span></span>Recompute <b>Oplock.State</b> according to the algorithm in
section 2.1.4.13, passing <b>Oplock</b> as the <b>ThisOplock</b> parameter.</p>

</li><li><p><span><span> 
</span></span>EndCase</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>Case (READ_CACHING|HANDLE_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> equals HANDLE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>For each <b>Open</b> <i>ThisOpen</i> in <b>Oplock.RHOplocks</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisOpen</i>.<b>OplockKey</b> does not equal <b>Open.OplockKey</b>:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisOpen</i> from <b>Oplock.RHOplocks</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to READ_CACHING.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.2.)</p>

</li><li><p><span><span> 
</span></span>Initialize a new <b>RHOpContext</b> object, setting its fields as
follows:</p>

<ul><li><p><span><span> 
</span></span><b>RHOpContext.Open</b> set to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>RHOpContext.BreakingToRead</b> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>Add the new <b>RHOpContext</b> object to <b>Oplock.RHBreakQueue</b>.</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <i>BreakCacheState</i> contains both READ_CACHING and
WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>For each <b>RHOpContext</b> <i>ThisContext</i> in <b>Oplock.RHBreakQueue</b>:</p>

<ul><li><p><span><span> 
</span></span>Call the algorithm in section 2.1.4.12.2, passing <b>Open</b> as
the <b>OperationOpen</b> parameter, <i>ThisContext</i>.<b>Open</b> as the <b>OplockOpen</b>
parameter, and <b>Flags</b> as the <b>Flags</b> parameter. If the algorithm
returns FALSE:</p>

<ul><li><p><span><span> 
</span></span>Set <i>ThisContext</i>.<b>BreakingToRead</b> to FALSE.</p>

</li><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains HANDLE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li><li><p><span><span> 
</span></span>For each <b>Open</b> <i>ThisOpen</i> in <b>Oplock.RHOplocks</b>:</p>

<ul><li><p><span><span> 
</span></span>Call the algorithm in section 2.1.4.12.2, passing <b>Open</b> as
the <b>OperationOpen</b> parameter, <i>ThisOpen</i> as the <b>OplockOpen</b>
parameter, and <b>Flags</b> as the <b>Flags</b> parameter. If the algorithm
returns FALSE:</p>

<ul><li><p><span><span> 
</span></span>Remove <i>ThisOpen</i> from <b>Oplock.RHOplocks</b>.</p>

</li><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.2.)</p>

</li><li><p><span><span> 
</span></span>Initialize a new <b>RHOpContext</b> object, setting its fields as
follows:</p>

<ul><li><p><span><span> 
</span></span><b>RHOpContext.Open</b> set to <i>ThisOpen</i>.</p>

</li><li><p><span><span> 
</span></span><b>RHOpContext.BreakingToRead</b> to FALSE.</p>

</li></ul></li><li><p><span><span> 
</span></span>Add the new <b>RHOpContext</b> object to <b>Oplock.RHBreakQueue</b>.</p>

</li><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains HANDLE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>// If the oplock is explicitly losing HANDLE_CACHING, <b>RHBreakQueue</b>
is not empty,</p>

</li><li><p><span><span> 
</span></span>// and the algorithm has not yet decided to wait, this operation
might have to wait if</p>

</li><li><p><span><span> 
</span></span>// there is an oplock on <b>RHBreakQueue</b> with a non-matching
key. This is done</p>

</li><li><p><span><span> 
</span></span>// because even if this operation didn't cause a break of a
currently-granted Read-</p>

</li><li><p><span><span> 
</span></span>// Handle caching oplock, it might have done so had a
currently-breaking oplock still</p>

</li><li><p><span><span> 
</span></span>// been granted.</p>

</li><li><p><span><span> 
</span></span>If (<i>NeedToWait</i> is FALSE) and</p>

<p>(<b>Oplock.RHBreakQueue</b>
is not empty) and</p>

<p>(<i>BreakCacheState</i>
contains HANDLE_CACHING):</p>

<ul><li><p><span><span> 
</span></span>For each <b>RHOpContext</b> <i>ThisContex</i> in <b>Oplock.RHBreakQueue</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisContext</i>.<b>Open.OplockKey</b> does not equal <b>Open.OplockKey</b>:</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li><li><p><span><span> 
</span></span>Break out of the For loop.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>Recompute <b>Oplock.State</b> according to the algorithm in
section 2.1.4.13, passing <b>Oplock</b> as the <b>ThisOplock</b> parameter.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case (READ_CACHING|HANDLE_CACHING|BREAK_TO_READ_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains READ_CACHING:</p>

<ul><li><p><span><span> 
</span></span>For each <b>RHOpContext</b> <i>ThisContext</i> in <b>Oplock.RHBreakQueue</b>:</p>

<ul><li><p><span><span> 
</span></span>Call the algorithm in section 2.1.4.12.2, passing <b>Open</b> as
the <b>OperationOpen</b> parameter, <i>ThisContext</i>.<b>Open</b> as the <b>OplockOpen</b>
parameter, and <b>Flags</b> as the <b>Flags</b> parameter. If the algorithm
returns FALSE:</p>

<ul><li><p><span><span> 
</span></span>Set <i>ThisContext</i>.<b>BreakingToRead</b> to FALSE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>Recompute <b>Oplock.State</b> according to the algorithm in
section 2.1.4.13, passing <b>Oplock</b> as the <b>ThisOplock</b> parameter.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains HANDLE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>For each <b>RHOpContext</b> <i>ThisContext</i> in <b>Oplock.RHBreakQueue</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisContext</i>.<b>Open.OplockKey</b> does not equal <b>Open.OplockKey</b>:</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li><li><p><span><span> 
</span></span>Break out of the For loop.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case (READ_CACHING|HANDLE_CACHING|BREAK_TO_NO_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains HANDLE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>For each <b>RHOpContext</b> <i>ThisContext</i> in <b>Oplock.RHBreakQueue</b>:</p>

<ul><li><p><span><span> 
</span></span>If <i>ThisContext</i>.<b>Open.OplockKey</b> does not equal <b>Open.OplockKey</b>:</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li><li><p><span><span> 
</span></span>Break out of the For loop.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndFor</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case (READ_CACHING|WRITE_CACHING|EXCLUSIVE):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains both READ_CACHING and
WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to 2.1.5.17.3
completes some earlier call to 2.1.5.17.1.)</p>

</li><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING).</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <i>BreakCacheState</i> contains WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to READ_CACHING.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.1.)</p>

</li><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to (READ_CACHING|WRITE_CACHING|
EXCLUSIVE|BREAK_TO_READ_CACHING).</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case (READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> equals WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to (READ_CACHING|HANDLE_CACHING).</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.1.)</p>

</li><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING|BREAK_TO_HANDLE_CACHING).</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <i>BreakCacheState</i> equals HANDLE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to (READ_CACHING|WRITE_CACHING).</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.1.)</p>

</li><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING|BREAK_TO_WRITE_CACHING).</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <i>BreakCacheState</i> contains both READ_CACHING and
WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Notify the server of an oplock break according to the algorithm
in section 2.1.5.17.3, setting the algorithm's parameters as follows:</p>

<ul><li><p><span><span> 
</span></span><b>BreakingOplockOpen</b> equal to <b>Oplock.ExclusiveOpen</b>.</p>

</li><li><p><span><span> 
</span></span><b>NewOplockLevel</b> equal to LEVEL_NONE.</p>

</li><li><p><span><span> 
</span></span><b>AcknowledgeRequired</b> equal to TRUE.</p>

</li><li><p><span><span> 
</span></span><b>OplockCompletionStatus</b> equal to STATUS_SUCCESS.</p>

</li></ul></li><li><p><span><span> 
</span></span>(The operation does not end at this point; this call to
2.1.5.17.3 completes some earlier call to 2.1.5.17.1.)</p>

</li><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING).</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case
(READ_CACHING|WRITE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains READ_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains either READ_CACHING or
WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case (READ_CACHING|WRITE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains either READ_CACHING or
WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING|BREAK_TO_WRITE_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> == WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <i>BreakCacheState</i> contains both READ_CACHING and
WRITE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to (READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING|BREAK_TO_HANDLE_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> == HANDLE_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>Else If <i>BreakCacheState</i> contains READ_CACHING:</p>

<ul><li><p><span><span> 
</span></span>Set <b>Oplock.State</b> to
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING).</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_READ_CACHING):</p>

<ul><li><p><span><span> 
</span></span>If <i>BreakCacheState</i> contains READ_CACHING, set <b>Oplock.State</b>
to (READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING).</p>

</li><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li><li><p><span><span> 
</span></span>Case
(READ_CACHING|WRITE_CACHING|HANDLE_CACHING|EXCLUSIVE|BREAK_TO_NO_CACHING):</p>

<ul><li><p><span><span> 
</span></span>Set <i>NeedToWait</i> to TRUE.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndCase</p>

</li></ul></li><li><p><span><span> 
</span></span>EndSwitch</p>

</li><li><p><span><span> 
</span></span>If <i>NeedToWait</i> is TRUE:</p>

<ul><li><p><span><span> 
</span></span>The operation that called this algorithm MUST be made cancelable
by inserting it into <b>CancelableOperations.CancelableOperationList</b>.</p>

</li><li><p><span><span> 
</span></span>Insert <b>Open</b> into <b>Oplock.WaitList</b>.</p>

</li><li><p><span><span> 
</span></span>The operation that called this algorithm waits until the oplock
break is acknowledged, as specified in section 2.1.5.18, or the operation is
canceled.</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul></li><li><p><span><span>  </span></span>EndIf</p>

</li></ul></li><li><p><span><span> 
</span></span>EndIf</p>

</li></ul><p>EndIf</p>


                </div>
            </div>
        </div>
    </body>
</html>